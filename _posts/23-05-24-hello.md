---
layout: post
title: Docker Containerizing
---

# Containerizing a Three-Tier Web Application with Docker: A Step-by-Step Guide

In today's fast-paced world of software development, containerization has become a crucial technique for building, deploying, and scaling applications efficiently. In this blog post, I'll walk you through the process of containerizing a three-tier web application using Docker. We'll cover everything from setting up Dockerfiles for each tier to integrating them using Docker Compose.

## Introduction

Containerization has revolutionized the way we develop and deploy software, offering a lightweight and portable solution for packaging applications and their dependencies. A three-tier web application typically consists of a presentation tier, an application tier, and a data tier. By containerizing each tier, we can streamline deployment and ensure consistency across different environments.

## Background

For this tutorial, I've chosen my web application available on GitHub [GitHub URL](https://github.com/SiddhantEngineer/Symphony---A-music-streaming-Webapp.git). This application follows a three-tier architecture, with a front-end(React) presentation tier, a back-end(Node, Express) application tier, and a database(MongoDB) as the data tier.

## Containerization Strategy

To containerize our three-tier web application, we'll leverage Docker, a popular containerization platform known for its simplicity and flexibility. We'll start by creating Dockerfiles for each tier, specifying the necessary dependencies and configurations.

## Containerizing the Presentation Tier

The presentation tier of our web application consists of the front-end code responsible for rendering the user interface. To containerize it, we'll create a Dockerfile that sets up the environment, installs dependencies, and copies the application code into the container.

### Dockerfile:

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

ENV PORT=5173

EXPOSE 5173

CMD ["npm", "run", "dev"]
```

### Breakdown of the Dockerfile:

---

```dockerfile
FROM node:18-alpine
```

This line specifies the base image for the Docker container. In this case, we're using the Node.js 18 image based on Alpine Linux, which is a lightweight Linux distribution. This image provides a minimal Node.js runtime environment, suitable for running Node.js applications efficiently.

---

```dockerfile
WORKDIR /app
```

This command sets the working directory inside the Docker container to /app. Subsequent commands will be executed relative to this directory.

---

```dockerfile
COPY package*.json ./
```

This line copies the package.json and package-lock.json files from the host machine to the /app directory inside the container. These files contain information about the Node.js application's dependencies.

---

```dockerfile
RUN npm install
```

This command runs npm install inside the container, which installs the dependencies listed in the package.json file. It ensures that all required Node.js modules are installed in the container environment.

---

```dockerfile
COPY . .
```

This command copies the rest of the application code (excluding package.json and package-lock.json) from the host machine to the /app directory inside the container. This includes all source code, configuration files, and static assets necessary for running the application.

---

```dockerfile
ENV PORT=5173
```

This line sets the environment variable PORT to 5173 inside the container. This variable specifies the port on which the Node.js application will listen for incoming HTTP requests.

---

```dockerfile
EXPOSE 5173
```

This command exposes port 5173 from the Docker container to allow external access. It informs Docker that the Node.js application running inside the container will be listening on port 5173 for incoming connections.

---

```dockerfile
CMD ["npm", "run", "dev"]
```

Finally, this command specifies the default command to be executed when the Docker container starts. In this case, it runs the npm run dev script, which typically starts a development server for the Node.js application.

---

In summary, this Dockerfile sets up a Docker container with Node.js environment, installs dependencies, copies the application code, sets environment variables, exposes ports, and specifies the default command to run the Node.js application.

### Building Docker File

Now that we have the dockerfile ready, we can follow the following steps to build the docker file into an image and then run it.

1. Save the dockerfile in the project directory. In our case it would be ./frontend
2. Open a terminal or command promt in that directory.
3. Run the following command for building the project.

   ```bash
   docker build -t <your_image_name> .
   ```

   In the above code, -t indicates tagName.you can put your desired imagename in "your_image_name" placeholder.

4. Once its built successfully, type in followin command.

   ```bash
   docker run -p 5173:5173 <your_image_name>
   ```

   This code wil start your app on port 5173 of your pc.

   -p indicates port number

   In 5173:5173, the number before ":" indicates the port number of your pc from which you want to access the dockercontainer and number after ":" indicated which port on the container should be accessed.
